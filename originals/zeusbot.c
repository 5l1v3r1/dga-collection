/**
 * Source:
 * http://vrt-blog.snort.org/2014/03/decoding-domain-generation-algorithms.html
 * Dave
 * March 6, 2014
 */
 /*
gcc -Wall dga.c -o dga -lcrypto -lssl

Use without args for todays date.
To generate domains for another date, simply run with:

./dga mmddyyyy

*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <openssl/md5.h>

#define HASHLEN 16

int GetMD5Hash (unsigned char *pbData, int size, unsigned char *hashValue);
int genURL (unsigned char *hashValue, char *URL);
int genTLD (unsigned short rand, char *TLD);
int genDate(unsigned char *dateData);

int genSuppliedDate(char *argv[], unsigned char *dateData) {
    int year;
    unsigned char month;
    unsigned char day;

    long int a = strtol(argv[1], NULL, 10); // grab int without atoi
    month = a / 1000000;
    day = a / 10000 % 100;
    year = a % 10000;

    year = (year & 0xff) + 0x30; // Add 30h to last byte of year
    day = (day / 7) * 7;
  
    unsigned char combined[] = { year, month, day };
    memcpy(dateData, &combined, 4);

    return 1;
}

int genDate(unsigned char *dateData){
    unsigned char year;
    unsigned char month;
    unsigned char day;
   
    time_t currTime = time(NULL);
    struct tm *localTime;
    localTime = localtime(&currTime);
    year = ((localTime->tm_year + 1900) & 0xff) + 0x30; // Add 30h to last byte of year
    month = localTime->tm_mon + 1; // Just plain ol' month - Number of months since January + 1
    day = (localTime->tm_mday / 7) * 7;

    unsigned char combined[] = { year, month, day };
    memcpy(dateData, &combined, 4);

    return 1;
}
// Generate TLD based on random seed based on low-byte
// of random seed
int genTLD (unsigned short rand, char *TLD) {

    unsigned char lobyte = (rand & 0xff);

    if ((rand % 6) == 0) {
        strncpy(TLD,".ru",4);
    }
    else if ((rand % 5) == 0) {
        strncpy(TLD,".biz",5);
    }
    else if ((lobyte & 3) == 00) {
        strncpy(TLD,".info",6);
    }
    else if ((rand % 3) == 0) {
        strncpy(TLD,".org",5);
    }
    else if ((lobyte & 1) == 0) {
        strncpy(TLD,".net",5);
    }
    else {
        strncpy(TLD,".com",5);
    }
   
    return 1;
}

// Generate URL based on MD5 hash
int genURL(unsigned char *hashValue, char *URL) {
        // Grab each byte of hash
        unsigned int j;
        unsigned int currentIndex = 0; // Pointer to current index in URL array

        for(j = 0 ; j < HASHLEN ; j++) {
            unsigned char cl = hashValue[j];
            unsigned char dl = cl;
            dl = (dl & 0x1F) + 0x61;
            cl = (cl >> 3) + 0x61;
            if (cl != dl) {
                if (dl <= 0x7A){
                    URL[currentIndex] = dl;
                    currentIndex++;
                }
                if (cl <= 0x7A){
                    URL[currentIndex] = cl;
                    currentIndex++;
                }
            }
        }
    return 1;
}

//  Compute the MD5 checksum for generated bytes
int GetMD5Hash(unsigned char *pbData, int size, unsigned char *hashValue) {
    unsigned char digest[HASHLEN];
   
    MD5_CTX ctx;
    MD5_Init(&ctx);
    MD5_Update(&ctx, pbData, 7);
    MD5_Final(digest, &ctx);
   
    memcpy(hashValue, digest, HASHLEN);

    return 1;
}  

int main( int argc, char *argv[] )
{
    unsigned char dateData[3]; // Store Date data after modification
    char URL[33] = {}; // Store resulting generated URL, 32 bytes is max possible length + \0
    char TLD[6]; // Store generated TLD
   
    if ( argc == 2 ) {
        if (!(genSuppliedDate(argv, dateData))){
            return 0; // if the date fails, error out
        }
    }
    // Generate first 3 bytes for hash
    else if (!(genDate(dateData))) { // if the date fails, error out
            printf("Failed to generate date hash data, exiting");
            return 0;
            // Failure
    }
   
   
    unsigned short i;
    for (i = 0; i < 1000; i++){ // need to +1 because it ranges from 0000-1000
        unsigned char hashValue[HASHLEN]; // MD5 Hash of given bytes
        memset(URL, 0, sizeof(URL)); // clear arrays
        memset(TLD, 0, sizeof(TLD)); // clear arrays

        // Reverse order of bytes when generating URLs,
        // This will match the order in how it URLs are
        // incremented in the malware itself
        unsigned char hibyte = (i >> 8) & 0xff;
        unsigned char lobyte = (i & 0xff);
        // unsigned short combined = lobyte << 8 | hibyte;
           
        unsigned char pbData[7] = { dateData[0], dateData[1], dateData[2], lobyte, hibyte, 0x00, 0x00}; // Given Bytes
           
        if (GetMD5Hash(pbData, sizeof(pbData), hashValue)) { // If MD5 Successful
            if (genURL(hashValue, URL)) {
                unsigned short k;
                // Print URL
                for(k = 0; k < strlen(URL); k++){
                        printf("%c", URL[k]);
                }
                if (genTLD(i, TLD)) { // random value (Before flipping it around for the hash)
                    // Print TLD
                    for(k = 0; k < strlen(TLD); k++){
                            printf("%c", TLD[k]);
                    }
                    printf("\n");
                }
            }
        }
    } // count loop
   return 0;
}
